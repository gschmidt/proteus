// TODO: listen to the framework to find out when client code changes,
// and push the changes to the client. current thinking: the client
// will keep all of its durable state in a session object, which it
// will save across the code reload. (ideally the code reload will be
// done without an actual reload, if we can find a way to sandbox the
// whole app, say in an iframe, and then throw it away, and if we do
// things that way session doesn't need to ever be sent to the
// server. otherwise, client would have to temporary bounce the
// session data through the server on reload.)
//
// TODO: are JSON.parse/JSON.stringify universally supported?? .. unlikely!!
// TODO: catch all exceptions
// TODO: tests
// TODO: automatically reconnect if server restarts.. use reasonable backoff
// -> possible implication: client as independent application that can run
//    separate from server very happily
//    -> look at offline caching ..

// TODO: see if paperboy actually gets caching right
// TODO: register restart dependency on html/css/js files that are served?

#require('/framework/lib/basics.js')
#require('/framework/lib/LongPollServer.js')

var
  sys = require('sys'),
  path = require('path'),
  http = require('http'),
  url = require('url'),
  paperboy = require('../3rdparty/paperboy'),

  PORT = 4000,
  WEBROOT = path.join(project_root, 'public');


///// MONGO TEST /////////

var Db = require('../3rdparty/node-mongodb-native/lib/mongodb').Db,
  Connection = require('../3rdparty/node-mongodb-native/lib/mongodb').Connection,
  Server = require('../3rdparty/node-mongodb-native/lib/mongodb').Server,
  BSON = require('../3rdparty/node-mongodb-native/lib/mongodb').BSONPure;
  //BSON = require('../3rdparty/node-mongodb-native/lib/mongodb').BSONNative;



var host = 'localhost';
var port = Connection.DEFAULT_PORT;
sys.puts("Connecting to " + host + ":" + port);
// for some reason, native_parser:true is failing:
//   Error: Cannot find module '../../external-libs/bson/bson'
// yet build/node-mongodb-native/external-libs/bson/bson.node exists..

var db = new Db('node-mongo-examples', new Server(host, port, {}), {native_parser:false});
db.open(function(err, db) {
  db.dropDatabase(function(err, result) {
    db.collection('test', function(err, collection) {
      sys.puts("COLL: " + collection);
      sys.puts("ERR: " + err);
      // Erase all records from the collection, if any
      collection.remove(function() {
        // Insert 3 records
        for(var i = 0; i < 3; i++) {
          collection.insert({'a':i});
        }
        
        collection.count(function(err, count) {
          sys.puts("There are " + count + " records in the test collection. Here they are:");

          collection.find(function(err, cursor) {
            cursor.each(function(err, item) {
              if(item != null) {
                sys.puts(sys.inspect(item));
                sys.puts("created at " + new Date(item._id.generationTime) + "\n")
              }
              // Null signifies end of iterator
              if(item == null) {                
                // Destory the collection
                collection.drop(function(err, collection) {
                  db.close();
                });
              }
            });
          });          
        });
      });      
    });
  });
});
////// END STUPID LAME TEST ////////////










var long_poll_server = LongPollServer.create("/ev");
ALL_CONNECTIONS = {}; // map from URL to connection object

var client_file_object = getFileObject('client/main.js');
if (!client_file_object)
  throw new Error("Can't find client/main.js");
var client_code_errors = client_file_object.preflight();
if (is_debug_mode) {
  client_file_object.onDirty(function() {
    for (url in ALL_CONNECTIONS) {
      if (ALL_CONNECTIONS.hasOwnProperty(url)) {
        var conn = ALL_CONNECTIONS[url];
        conn.send('reload');
      }
    }
    // TODO: this sucks. we should restart immediately, and *then*
    // tell the clients? somehow?
    // TODO: this actually doesn't work at all. the client restarts,
    // gets a new cookie, and then the server immediately restarts,
    // invalidating the cookie
    setTimeout(restart, 3*1000);
  });
}
if (client_code_errors.length > 0) {
  // TODO: It would be nice to have a unified error display for client
  // and server code. This will require not thinking about the path to
  // the client code as being dynamically generated by the server
  // code.
  console.log("============================");
  console.log("There Are Client Code Errors");
  console.log("============================");
  client_code_errors.forEach(function (e) {
    console.log(e.toString());
  });
  client_bundle = null;
} else {
  client_bundle = client_file_object.getBundle('/bundle');
}

var startup = function () {
  http.createServer(function(req, res) {
    var url = require('url');
    var pathname = url.parse(req.url).pathname || '';

    if (pathname === '/') {
      var conn_info = long_poll_server.createConnection();
      var conn_obj = conn_info[0];
      var conn_url = conn_info[1];
      // TODO: clean up when connection goes away! (..make connections go away!)
      ALL_CONNECTIONS[conn_url] = conn_obj;
      var client_env = {
        connection: conn_url
      };

      var env_setup = "<script>ENVIRONMENT = {" +
        mapProperties(client_env, function (k,v) {
          return k + ": " + JSON.stringify(v);}).
        join(",") + "}</script>";

      var script_includes = client_bundle.paths.map(function (path) {
        return '<script src="' + path + '"></script>';
      }).join('');

      var page = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head>' + env_setup + script_includes + '</head><body></body></html>';

      var onMessage = function (m) {
        conn_obj.send("You said: " + m);
      };
      var onStateChange = function () {
      };
      conn_obj.setHandlers(onMessage, onStateChange);

      res.writeHead(200, {'Content-Type': 'text/html'});
      res.end(page);
      return;
    }
    if (pathname === '/ev') {
      long_poll_server.handleRequest(req, res);
      return;
    }
    if (req.url.match(/^\/bundle\/.*$/)) {
      if (!(req.url in client_bundle.data)) {
        res.writeHead(404);
        res.end();
        return;
      }
      // Ask for the bundle to be cached forever without
      // revalidation. (There is some RFC somewhere that says that
      // "forever" should be about a year in the future.) We put the
      // current hash in the URL to control reloading. And we put it in
      // the filename rather than the query string because of a rumor
      // that the Squid cache sucks.
      var expires = new Date();
      expires.setTime(expires.getTime() + 365*24*60*60*1000);

      res.writeHead(200, {
        'Content-Type': 'application/javascript',
        'Expires': expires.toUTCString()
      });
      res.end(client_bundle.data[req.url]);
      return;
    }

    var ip = req.connection.remoteAddress;
    paperboy
      .deliver(WEBROOT, req, res)
      .addHeader('Expires', 300)
      .before(function() {
        sys.log('Received Request');
      })
      .after(function(statCode) {
        log(statCode, req.url, ip);
      })
      .error(function(statCode, msg) {
        res.writeHead(statCode, {'Content-Type': 'text/plain'});
        res.end("Error " + statCode);
        log(statCode, req.url, ip, msg);
      });
  }).listen(PORT);
}

function log(statCode, url, ip, err) {
  var logStr = statCode + ' - ' + url + ' - ' + ip;
  if (err)
    logStr += ' - ' + err;
  sys.log(logStr);
}

if (client_bundle !== null)
  startup();