// TODO: listen to the framework to find out when client code changes,
// and push the changes to the client. current thinking: the client
// will keep all of its durable state in a session object, which it
// will save across the code reload. (ideally the code reload will be
// done without an actual reload, if we can find a way to sandbox the
// whole app, say in an iframe, and then throw it away, and if we do
// things that way session doesn't need to ever be sent to the
// server. otherwise, client would have to temporary bounce the
// session data through the server on reload.)
//
// TODO: are JSON.parse/JSON.stringify universally supported?? .. unlikely!!
// TODO: catch all exceptions
// TODO: tests
// TODO: automatically reconnect if server restarts.. use reasonable backoff
// -> possible implication: client as independent application that can run
//    separate from server very happily
//    -> look at offline caching ..

// TODO: see if paperboy actually gets caching right
// TODO: register restart dependency on html/css/js files that are served?

#require('/framework/lib/basics.js')
#require('/framework/lib/LongPollServer.js')
#require('/framework/lib/ServerSession.js')
#require('/server/PeopleServer.js')

var
  sys = require('sys'),
  path = require('path'),
  http = require('http'),
  url = require('url'),
  paperboy = require('../3rdparty/paperboy'),

  PORT = 4000,
  WEBROOT = path.join(project_root, 'public');

var long_poll_server = LongPollServer.create("/ev");
var server_session = ServerSession.create();

var client_file_object = getFileObject('client/main.js');
if (!client_file_object)
  throw new Error("Can't find client/main.js");
var client_code_errors = client_file_object.preflight();
if (is_debug_mode) {
  client_file_object.onDirty(function() {
    server_session.post('reload');
    // TODO: this sucks. we should restart immediately, and *then*
    // tell the clients? somehow?
    // TODO: this actually doesn't work at all. the client restarts,
    // gets a new cookie, and then the server immediately restarts,
    // invalidating the cookie
    setTimeout(restart, 3*1000);
  });
}
if (client_code_errors.length > 0) {
  // TODO: It would be nice to have a unified error display for client
  // and server code. This will require not thinking about the path to
  // the client code as being dynamically generated by the server
  // code.
  console.log("============================");
  console.log("There Are Client Code Errors");
  console.log("============================");
  client_code_errors.forEach(function (e) {
    console.log(e.toString());
  });
  client_bundle = null;
} else {
  client_bundle = client_file_object.getBundle('/bundle');
}

server_session.onRpc('message', function (m, reply) {
  server_session.post('message', "You said: " + m);
  reply(true);
});

PeopleServer.create(server_session);

var startup = function () {
  http.createServer(function(req, res) {
    var url = require('url');
    var pathname = url.parse(req.url).pathname || '';

    if (pathname === '/') {
      var conn_info = long_poll_server.createConnection();
      var conn_obj = conn_info[0];
      var conn_url = conn_info[1];
      server_session.setupConnection(conn_obj);
      var client_env = {
        connection: conn_url
      };

      var env_setup = "<script>ENVIRONMENT = {" +
        mapProperties(client_env, function (k,v) {
          return k + ": " + JSON.stringify(v);}).
        join(",") + "}</script>";

      var script_includes = client_bundle.paths.map(function (path) {
        return '<script src="' + path + '"></script>';
      }).join('');

      var page = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head>' + env_setup + script_includes + '</head><body></body></html>';

      res.writeHead(200, {'Content-Type': 'text/html'});
      res.end(page);
      return;
    }
    if (pathname === '/ev') {
      long_poll_server.handleRequest(req, res);
      return;
    }
    if (req.url.match(/^\/bundle\/.*$/)) {
      if (!(req.url in client_bundle.data)) {
        res.writeHead(404);
        res.end();
        return;
      }
      // Ask for the bundle to be cached forever without
      // revalidation. (There is some RFC somewhere that says that
      // "forever" should be about a year in the future.) We put the
      // current hash in the URL to control reloading. And we put it in
      // the filename rather than the query string because of a rumor
      // that the Squid cache sucks.
      var expires = new Date();
      expires.setTime(expires.getTime() + 365*24*60*60*1000);

      res.writeHead(200, {
        'Content-Type': 'application/javascript',
        'Expires': expires.toUTCString()
      });
      res.end(client_bundle.data[req.url]);
      return;
    }

    var ip = req.connection.remoteAddress;
    paperboy
      .deliver(WEBROOT, req, res)
      .addHeader('Expires', 300)
      .before(function() {
        sys.log('Received Request');
      })
      .after(function(statCode) {
        log(statCode, req.url, ip);
      })
      .error(function(statCode, msg) {
        res.writeHead(statCode, {'Content-Type': 'text/plain'});
        res.end("Error " + statCode);
        log(statCode, req.url, ip, msg);
      });
  }).listen(PORT);
}

function log(statCode, url, ip, err) {
  var logStr = statCode + ' - ' + url + ' - ' + ip;
  if (err)
    logStr += ' - ' + err;
  sys.log(logStr);
}

if (client_bundle !== null)
  startup();