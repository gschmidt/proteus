// TODO: listen to the framework to find out when client code changes,
// and push the changes to the client. current thinking: the client
// will keep all of its durable state in a session object, which it
// will save across the code reload. (ideally the code reload will be
// done without an actual reload, if we can find a way to sandbox the
// whole app, say in an iframe, and then throw it away, and if we do
// things that way session doesn't need to ever be sent to the
// server. otherwise, client would have to temporary bounce the
// session data through the server on reload.)
//
// TODO: are JSON.parse/JSON.stringify universally supported?? .. unlikely!!
// TODO: catch all exceptions
// TODO: tests
// TODO: automatically reconnect if server restarts.. use reasonable backoff
// -> possible implication: client as independent application that can run
//    separate from server very happily
//    -> look at offline caching ..

// TODO: see if paperboy actually gets caching right
// TODO: register restart dependency on html/css/js files that are served?

#require('/framework/lib/basics.js')
#require('/framework/lib/LongPollServer.js')
#require('/framework/lib/ServerSession.js')
#require('/server/PeopleServer.js')
#require('/server/LoginServer.js')

var
  sys = require('sys'),
  path = require('path'),
  http = require('http'),
  url = require('url'),
  paperboy = require('../3rdparty/paperboy'),

  PORT = 4000,
  WEBROOT = path.join(project_root, 'public');

// TODO: find a better place for these
var CSS_FILES = ["reset.css", "grid.css", "index.css"];

var long_poll_server = LongPollServer.create("/ev");
var server_session = ServerSession.create();

var client_file_object = getFileObject('client/main.js');
if (!client_file_object)
  throw new Error("Can't find client/main.js");
var client_code_errors = client_file_object.preflight();
if (is_debug_mode) {
  // in debug mode, watch all of the resources that are sent to the
  // client, and send the client a reload messages if they've changed
  var endTheWorld = function() {
    console.log("**** Client sources changed; sending reload to client ****");
    server_session.post('reload');
    // TODO: this sucks. we should restart immediately, and *then*
    // tell the clients? somehow?
    // TODO: this actually doesn't work at all. the client restarts,
    // gets a new cookie, and then the server immediately restarts,
    // invalidating the cookie
    // TODO: actually this sucks, it means the old code gets reloaded
    setTimeout(restart, 1*1000);
  };

  // this gets all the javascript
  client_file_object.onDirty(endTheWorld);

  // css isn't currently handled by the bundler, so we have to do it
  // manually
  CSS_FILES.forEach(function (f) {
    var fullpath = path.join(WEBROOT, f);
    onPathDirty(fullpath, endTheWorld);
  });
}

if (client_code_errors.length > 0) {
  // TODO: It would be nice to have a unified error display for client
  // and server code. This will require not thinking about the path to
  // the client code as being dynamically generated by the server
  // code.
  console.log("============================");
  console.log("There Are Client Code Errors");
  console.log("============================");
  client_code_errors.forEach(function (e) {
    console.log(e.toString());
  });
  client_bundle = null;
} else {
  client_bundle = client_file_object.getBundle('/bundle');
}

// Bring up Mongo, and when that's done, call 'callback' with one
// argument, the Mongo database handle.
var startMongo = function (callback) {
  var db = require('../3rdparty/node-mongodb-native/lib/mongodb').Db;
  var server = require('../3rdparty/node-mongodb-native/lib/mongodb').Server;

  // XXX pull out config information
  var mongo = new db('proteus', new server("127.0.0.1", 27017, {}), {});
  if (false) {
    // XXX make this work
    var BSON = require("../external-libs/bson/bson");
    mongo.bson_deserializer = BSON;
    mongo.bson_serializer = BSON;
    mongo.pkFactory = BSON.ObjectID;
  } else {
    var BSONJS = require('../3rdparty/node-mongodb-native/lib/mongodb/bson/bson');
    mongo.bson_deserializer = BSONJS;
    mongo.bson_serializer = BSONJS;
    mongo.pkFactory = BSONJS.ObjectID;
  }
  mongo.open(function(err, mongo) {
    // XXX handle error
    callback(mongo);
  });
};

// Bring up the HTTP server and start accepting requests (both for
// RPC/event subscrption channel and static resources)
var startHttp = function () {
  http.createServer(function(req, res) {
    var url = require('url');
    var pathname = url.parse(req.url).pathname || '';

    if (pathname === '/') {
      var conn_info = long_poll_server.createConnection();
      var conn_obj = conn_info[0];
      var conn_url = conn_info[1];
      server_session.setupConnection(conn_obj);
      var client_env = {
        connection: conn_url
      };

      var env_setup = "<script>ENVIRONMENT = {" +
        mapProperties(client_env, function (k,v) {
          return k + ": " + JSON.stringify(v);}).
        join(",") + "}</script>";

      var script_includes = client_bundle.paths.map(function (path) {
        return '<script src="' + path + '"></script>';
      }).join('');

      var css_includes = CSS_FILES.map(function (path) {
        return '<link href="' + path + '" rel="stylesheet" type="text/css">';
      }).join('');

      var page = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head>' + env_setup + css_includes + script_includes + '</head><body></body></html>';

      res.writeHead(200, {'Content-Type': 'text/html'});
      res.end(page);
      return;
    }
    if (pathname === '/ev') {
      long_poll_server.handleRequest(req, res);
      return;
    }
    if (req.url.match(/^\/bundle\/.*$/)) {
      if (!(req.url in client_bundle.data)) {
        res.writeHead(404);
        res.end();
        return;
      }
      // Ask for the bundle to be cached forever without
      // revalidation. (There is some RFC somewhere that says that
      // "forever" should be about a year in the future.) We put the
      // current hash in the URL to control reloading. And we put it in
      // the filename rather than the query string because of a rumor
      // that the Squid cache sucks.
      var expires = new Date();
      expires.setTime(expires.getTime() + 365*24*60*60*1000);

      res.writeHead(200, {
        'Content-Type': 'application/javascript',
        'Expires': expires.toUTCString()
      });
      res.end(client_bundle.data[req.url]);
      return;
    }

    var log_http = function(statCode, url, ip, err) {
      var logStr = statCode + ' - ' + url + ' - ' + ip;
      if (err)
        logStr += ' - ' + err;
      sys.log(logStr);
    };

    var ip = req.connection.remoteAddress;
    paperboy
      .deliver(WEBROOT, req, res)
      .addHeader('Expires', 300)
      .before(function() {
        sys.log('Received Request');
      })
      .after(function(statCode) {
        log_http(statCode, req.url, ip);
      })
      .error(function(statCode, msg) {
        res.writeHead(statCode, {'Content-Type': 'text/plain'});
        res.end("Error " + statCode);
        log_http(statCode, req.url, ip, msg);
      });
  }).listen(PORT);
};

var startup = function () {
  startMongo(function (mongo) {
    PeopleServer.create(server_session, mongo);
    LoginServer.create(server_session, mongo);
    startHttp();
  });
};

if (client_bundle !== null)
  startup();
